<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Color Picker</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="app" v-bind:style="{ backgroundColor: colors.hex}">
    <div class="color">
      <input type="text" maxlength="7" placeholder="#000000"
        v-bind:style="{ color: colors.hex}" v-model="colors.hex"
        v-on:change="onChangeHex" />
    </div>
    <p> {{ colors }}</p>

    <vue-slider v-model="colors.hsv.h"></vue-slider>

    <input id="hue" type="range" min="0" max="360" class="range white"
      v-model="colors.hsv.h" v-on:change="onChange" v-on:input="onChange"/>
    <input id="sat" type="range" min="0" max="1" step="any" class="range white"
      v-model="colors.hsv.s" v-on:change="onChange" v-on:input="onChange" />
    <input id="val" type="range" min="0" max="1" step="any" class="range white"
      v-model="colors.hsv.v" v-on:change="onChange" v-on:input="onChange" />

    <div id="box" v-bind:style="{ backgroundColor: colors.hex}"></div>

  </div>

  <script src="https://cdn.jsdelivr.net/npm/vue"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.4.1/tinycolor.min.js"></script>
  <script>
    var initColor = tinycolor.random();
    var initHSV = initColor.toHsv();

    function _colorChange(data, source) {
      // Data is either h, s, or v (from sliders)
      // Or a hex from text box
      var color
      /*
      if (source === 'hex') {
        color = tinycolor(data.hsv)
      }
      */

      console.log("SOURCE", source)
      console.log("DATA", data)

      // hsl is better than hex between conversions
      if (data && data.hsv && source === 'hsv') {
        console.log("HSV", data.hsv)
        color = tinycolor(data.hsv)
      } else if (data && data.hex && source === 'hex') {
        console.log("HEX", data.hex)
        color = tinycolor(data.hex)
      } else if (data && source === 'tinycolor') {
        console.log("TINYCOLOR")
        color = data
        console.log(color)
      } else {
        console.log('INVALID')
        console.log(source, data)
        color = tinycolor(data)
      }

      var hsv = color.toHsv()

      // when the hsv.v is less than 0.0164 (base on test)
      // because of possible loss of precision
      // the result of hue and saturation would be miscalculated
      if (hsv.v < 0.0164) {  // Stuck on black
        hsv.h = data.h || (data.hsv && data.hsv.h) || 0
        hsv.s = data.s || (data.hsv && data.hsv.s) || 0
      }
      if (hsv.s < 0.0164) {  // Stuck on black
        hsv.h = data.h || (data.hsv && data.hsv.h) || 0
        hsv.s = data.s || (data.hsv && data.hsv.s) || 0
      }
      if (hsv.h === 360 || hsv.h === 0) {
        // Flips between 0/360 in some cases. Go with whichever value was
        // closer in the previous state
        prev_h = data.hsv.h
        if (360-prev_h < prev_h) {
          hsv.h = 360
        } else {
          hsv.h = 0
        }
      }

      return {
        hex: color.toHexString().toUpperCase(),
        hsv: hsv,
        //source: data.source,
      }
    }

    var app = new Vue({
      el: '#app',
      props: ['value'],
      data() {
        return {
          color: _colorChange(initColor, 'tinycolor')
        }
      },
      computed: {
        colors: {
          get() {
            return this.color
          },
          set(newVal) {
            this.val = newVal
            this.$emit('input', newVal)
          }
        },
      },
      methods: {
        onChangeHex() {
          var context = this.color
          this.colors = Vue.nextTick(_colorChange(context, 'hex'))
        },
        onChange () {
          var context = this.color
          this.colors = Vue.nextTick(_colorChange(context, 'hsv'))
        },
      },
    })
  </script>

</body>

</html>
