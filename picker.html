<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Color Picker</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="app" v-bind:style="{ backgroundColor: colors.hex}">
    <div class="color">
      <input type="text" maxlength="7" placeholder="#000000"
        v-bind:style="{ color: colors.hex}" v-model="colors.hex"
        @change="onChangeHex"  @input="onChangeHex" />
    </div>
    <p> {{ colors }}</p>

    <vue-slider v-model="colors.hsv.h"></vue-slider>

    <input id="hue" type="range" min="0" max="360" class="range white"
      v-model="colors.hsv.h" @change="onChange"  @input="onChange"/>
    <input id="sat" type="range" min="0" max="1" step="any" class="range white"
      v-model="colors.hsv.s" @change="onChange" @input="onChange" />
    <input id="val" type="range" min="0" max="1" step="any" class="range white"
      v-model="colors.hsv.v" @change="onChange" @input="onChange" />

    <div id="box" v-bind:style="{ backgroundColor: colors.hex}"></div>

  </div>

  <script src="https://cdn.jsdelivr.net/npm/vue"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.4.1/tinycolor.min.js"></script>
  <script>

    var initColor = tinycolor.random();
    var initHSV = initColor.toHsv();

    function _colorChange(data, source) {
      // Data is either h, s, or v (from sliders)
      // Or a hex from text box
      var color

      if (source === 'hex') {
        color = tinycolor(data.hsv)
      }

      // hsl is better than hex between conversions
      if (data && data.hsv) {
        console.log("HSV", data.hsv)
        color = tinycolor(data.hsv)
      } else if (data && data.hex && data.hex.length > 0) {
        console.log("HEX", hex)
        color = tinycolor(data.hex)
      } else {
        console.log("INVALID")
        console.log(data)
        color = tinycolor(data)
      }

      var hsv = color.toHsv()

      // when the hsv.v is less than 0.0164 (base on test)
      // because of possible loss of precision
      // the result of hue and saturation would be miscalculated
      if (hsv.v < 0.0164) {  // Stuck on black
        hsv.h = data.h || (data.hsv && data.hsv.h) || 0
        hsv.s = data.s || (data.hsv && data.hsv.s) || 0
      }
      if (hsv.s < 0.0164) {  // Stuck on black
        hsv.h = data.h || (data.hsv && data.hsv.h) || 0
        hsv.s = data.s || (data.hsv && data.hsv.s) || 0
      }
      if (hsv.h === 360 || hsv.h === 0) {
        // Flips between 0/360 in some cases. Go with whichever value was
        // closer in the previous state
        prev_h = data.hsv.h
        if (360-prev_h < prev_h) {
          hsv.h = 360
        } else {
          hsv.h = 0
        }
      }

      return {
        hex: color.toHexString().toUpperCase(),
        hsv: hsv,
        //source: data.source,
      }
    }

    var app = new Vue({
      el: '#app',
      data() {
        return {
          colors: _colorChange(initHSV, 'hsv')
        }
      },
      computed: {
        colors: {
          get() {
            return this.val
          },
          set(newVal) {
            this.val = newVal
            this.$emit('input', newVal)
          }
        },
      },
      methods: {
        onChangeHex() {
          this.colors =Vue.nextTick(_colorChange(this.colors, 'hex'))
        },
        onChange () {
          this.colors =Vue.nextTick(_colorChange(this.colors, 'hsv'))
        },
      },
    })
  </script>

</body>

</html>
